AUTOSAR
==
# 1. autosar란?

AUTOSAR(AUTomotive Open System ARchitecture)는 자동차 소프트웨어 개발의 표준화를 위해 만들어진 개방형 아키텍처입니다.

자동차의 전자제어장치(ECU)에 들어가는 소프트웨어를 개발하고 관리하는 방식을 표준화하여, 여러 자동차 제조사와 부품 공급업체가 소프트웨어를 쉽게 공유하고 재사용할 수 있도록 하는 것이 핵심 목표  

기능(소프트웨어)과 제어기(하드웨어)를 완전히 분리해서 개발하고,  

마치 스마트폰에 앱을 설치하듯이, 만들어진 소프트웨어 기능들을 원하는 제어기에 쏙쏙 집어넣는 방식입니다.

## 1-1. autosar도입된 이유

<img width="1056" height="430" alt="image" src="https://github.com/user-attachments/assets/df3c835f-334d-47a8-8cad-5539d72e8183" />

점점 복잡해지고 비효율적으로 변하는 자동차 소프트웨어 개발 환경을 바로잡고,  

소프트웨어의 재사용성을 높여 개발 비용과 시간을 줄이기 위한 표준 규격으로 AUTOSAR가 등장  

## 1-2. 어떻게 중간다리 역할을 하나?

AUTOSAR는 애플리케이션(SWC) → 가상 통신망(RTE) → 표준 서비스(BSW) → 하드웨어 통역사(MCAL) 순서로 역할을 철저히 분담합니다.  

각 계층은 정해진 약속(인터페이스)으로만 대화하기 때문에, 맨 위에 있는 애플리케이션은 하드웨어가 어떻게 생겼는지 전혀 몰라도 되는 것입니다.   

그래서 특정 하드웨어가 바뀌면 그 하드웨어와 직접 대화하는 맨 아래 계층(MCAL)만 교체해주면, 그 위에 있는 모든 소프트웨어는 코드 수정 없이 그대로 재사용할 수 있게 됩니다.  

# 2. autosar의 layer


<img width="1214" height="619" alt="image" src="https://github.com/user-attachments/assets/4ba16b99-6eeb-4d71-99e4-94191b03f1cf" />


<img width="1245" height="660" alt="image" src="https://github.com/user-attachments/assets/a816ede3-99f4-4946-bfb4-a072a34fa815" />

## 2-1. AUTOSAR Application

ECU들에는 component들이 존재하고, 각 component들 안에는 실제 기능을 구현하기 위한 러너블들이 존재. 러너블들은 어떤 트리거 이벤트에 의해 트리거되어 실행됨.  

주기 이벤트 혹은 초기화 이벤트, 데이터 수신 이벤트 등 트리거 조건들을 설정할 수 있음. 또한, 트리거된 러너블들이 실행될 때는 OS Task에 매핑되어 동작함.  

마지막으로, software component들 간의 communication은 ECU내부, 외부 커뮤니케이션인지 고려하지 않고, RTE에게 요청하여 커뮤니케이션이 이루어지게 됨.  
****
구조: ECU > Component > Runnable  
자동차 소프트웨어의 구조는 마치 회사 조직도와 같습니다.  

- ECU: 하나의 '부서'

- 소프트웨어 컴포넌트(SWC): 부서 내의 '팀'

- 러너블(Runnable): 실제 업무를 수행하는 '팀원'

  하나의 ECU(부서) 안에는 여러 개의 SWC(팀)가 존재할 수 있고, 각 SWC(팀)는 특정 임무를 수행하는 여러 러너블(팀원)들로 구성됩니다.
****
실행: Event와 OS Task
'팀원(러너블)'은 아무 때나 일하는 것이 아니라, 명확한 **'업무 지시(Event)'**가 있을 때만 움직입니다.

- 이벤트 (Event) 기반 실행: 러너블을 실행시키는 '업무 지시'에는 다음과 같은 종류가 있습니다.

  - 주기 이벤트 (Timing Event): "10ms마다 한 번씩 보고해!"

  - 초기화 이벤트 (Init Event): "업무 시작할 때 딱 한 번만 실행해!"

  - 데이터 수신 이벤트 (Data Received Event): "다른 팀에서 자료가 도착하면 바로 확인해!"

- OS 태스크 (Task) 매핑: 이렇게 업무 지시를 받은 러너블들은 AUTOSAR OS가 관리하는 **'집중 근무 시간(Task)'**에 배정되어 실행됩니다. OS는 프로젝트 매니저처럼 여러 러너블의 실행 순서와 주기를 관리하여 ECU의 자원을 효율적으로 사용합니다. 하나의 태스크 안에 여러 러너블이 묶여서 함께 실행될 수도 있습니다.
****
통신: RTE의 역할
'팀(SWC)' 간의 소통은 **'사내 메신저/비서(RTE)'**를 통해서만 이루어집니다.

- 위치 투명성 (Location Transparency): A 컴포넌트가 B 컴포넌트에게 데이터를 보낼 때, B가 같은 ECU(내부 통신)에 있는지 다른 ECU(외부 통신)에 있는지 전혀 신경 쓸 필요가 없습니다.

- RTE의 중계: 그냥 "RTE, 이 데이터 좀 B한테 전달해줘"라고 요청만 하면, RTE가 알아서 내부 통신으로 처리할지, CAN이나 이더넷 같은 외부 통신으로 보낼지를 결정하고 실행합니다.

이러한 구조 덕분에 개발자는 하드웨어의 복잡한 구조나 통신 방식은 신경 끄고, 오직 소프트웨어의 기능 로직 개발에만 집중할 수 있게 됩니다.

## 2-2. AUTOSAR RTE

<img width="933" height="566" alt="image" src="https://github.com/user-attachments/assets/795b0c4b-c0e1-450a-9c8c-30d11a153299" />

ECU 내부, 외부 통신을 담당하는 미들웨어  

- 실행 지시: 어떤 기능을(러너블) 언제 실행할지 결정하고 OS에 지시합니다.  

- 통신 중계: 모든 소프트웨어 부품들 간의 데이터 교환을 도맡아 처리합니다.  

- 보호막 역할: 애플리케이션이 OS나 하드웨어 제어 SW에 직접 접근하는 것을 막아주는 안전장치입니다.
****
  SWC끼리 커뮤니케이션 필요할 때는 SWC가 RTE에게 요청. RTE는 SWC간의 커뮤니케이션(목적: 데이터 교환), SWC와 BSW끼리의 커뮤니케이션(BSW에게 서비스 요청) 제공
****
- AUTOSAR (전체 설계도):

  - Application Layer (앱)

  - RTE (중간 관리자)

  - BSW (기반 소프트웨어)

RTE가 외부 통신이 필요한지 판단하는 기준은 데이터 매핑 설정 정보를 기준으로 판단.  
****
Sender/Receiver communication
- direct(explicit): "지금 값 줘"라고 직접 요청해서 즉시 받는 1:1 통신.  
- buffered(implicit): 최신 값 하나만 자동으로 덮어쓰며 유지되는 방식 (이전 값은 무시됨).   
- queued: 모든 데이터를 순서대로 차곡차곡 쌓아놓고 하나씩 처리하는 방식 (데이터 손실 없음).
****
Client/Server communication  

클라이언트 (손님): 서버에게 특정 작업을 해달라고 요청합니다.  
서버 (요리사): 요청받은 작업을 수행하고 결과를 돌려줍니다.  

호출 방식:
- 동기 (Synchronous): 요청 후 결과가 올 때까지 기다립니다.
- 비동기 (Asynchronous): 요청만 하고 기다리지 않고 바로 다음 일을 합니다.
****
**문제**: 경합 상태 (Race Condition)  
여러 기능(러너블)이 하나의 공유 변수에 동시 접근 시, 실행 순서에 따라 데이터가 오염되는 문제.  

**해결책**  
Exclusive Area (EA):  
코드 블록 전체를 잠금(Lock)하여, 여러 줄의 연산이 중간에 방해받지 않도록 보장합니다.  

Inter-Runnable Variable (IRV):  
단일 변수에 대한 접근을 RTE가 제공하는 안전한 전용 읽기/쓰기 함수로만 제한합니다.   
****
RTE의 부가적인 기능 Multiple Instantiation: 붕어빵. 하나의 붕어빵틀로 수많은 붕어빵을 계속해서 찍어냄
