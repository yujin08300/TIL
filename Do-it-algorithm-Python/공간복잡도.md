int a[1000]: 4KB
int a[1000000]: 4MB
int a[2000][2000]: 16MB
코딩 테스트에서는 보통 메모리 사용량을 128MB ~ 512MB 정도로 제한한다. 다시 말하면, 일반적인 경우 데이터의 개수가 1000만 단위가 넘어가지 않도록 알고리즘을 설계해야 한다는 것이다. 만약 배열의 크기가 1000만 단위 이상이라면 알고리즘을 잘못 설계한 것이 아닌지 생각해봐야 한다.

 

❗️보통 시간 복잡도와 공간 복잡도는 Trade-Off 관계를 가진다.❗️
메모리를 조금 더 많이 사용하는 대신, 반복되는 연산을 생략하거나 더 많은 정보를 관리하면서 계산의 복잡도를 줄일 수 있다.
이때, 메모리를 더 소모하는 대신에 얻을 수 있는 시간적 이점이 매우 큰 경우가 종종 있다. 이렇게 메모리를 더 많이 사용해서 시간을 비약적으로 줄이는 방법으로 Memoization 기법이 있다.

(예를 들면 숫자와 관련한 문제에서, 복잡한 알고리즘을 쓰는 대신 가능한 최대 숫자만큼의 배열을 만들어버리는 것이 나을 때가 있다.)

📝 공간복잡도.
정의 : 입력의 크기와 문제를 해결하는데 걸리는 공간의 상관관계
코테에서는 보통 공간복잡도보다 시간복잡도 때문에 문제를 틀리는 경험을 많이 하게된다.
제한사항에 메모리 제한이 512MB라면 1.2억개의 인수를 갖는 int 배열을 가질 수 있다는 걸 기억하면 좋음
📝 정수 자료형
Java의 경우 각 자료형당 차지하는 크기는 다음과 같다.

데이터 형식	크기	허용 범위	개수  
boolean	1 바이트	true, false	2^7-1(=127)  
char	2 바이트	유니코드 문자	2^15-1(=32767)  
byte	1 바이트	-128 ~ 127	2^7-1(=127)  
short	2 바이트	-32,768 ~ 32,767	2^15-1(=32767)  
int	4 바이트	-2,147,483,648 ~ 2,147,483,647	2^31-1(≈2.1 * 10^9)  
long	8 바이트	-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807	2^63-1(≈9.2*10^18)  
float	4 바이트	±(1.40 × 10^-45 ~ 3.40 × 10^38)	2^31-1(≈2.1 * 10^9)  
double	8 바이트	+(4.94 x 10^-324 ~ 1.79 × 10^308)	2^63-1(≈9.2*10^18)  
먄약 80번째 피보나치 수 같이 int 자료형의 표현할 수 있는 범위를 벗어나면 long 자료형을 사용해야한다!  

📝 실수 자료형
실수의 저장과 연산에서 오차가 발생할 수 있음을 인지할 것.
실수의 자료형을 다룰때 알고있어야 하는 점은 실수의 저장과 연산 과정에서 반드시 오차가 발생할 수 있다는 것이다.

0.1+0.1+0.1이 0.3과 다르게 나오는 이유는 2진수 기준으로 무한 소수인 0.1을 유한한 크기의 fraction field에 저장하려고 할 때 발생하는 오차 때문!

fraction field 는 float은 앞 23 bit, double은 앞 52 bit까지만 저장 가능

데이터 형식	크기	허용 범위	개수	유효숫자  
float	4 바이트	±(1.40 × 10^-45 ~ 3.40 × 10^38)	2^31-1(≈2.1 * 10^9)	6자리  
double	8 바이트	+(4.94 x 10^-324 ~ 1.79 × 10^308)	2^63-1(≈9.2*10^18)	15자리  
→ float은 상대 오차 10^(-6)까지 안전하고 double은 10^(-15)까지 안전  

실수 자료형이 필요한 문제에서는 절대/상대 오차를 허용한다는 단서가 없다면  
열에 아홉은 실수를 안쓰고 모든 연산을 정수에서 해결할 수 있는 문제!  

double 자료형에 long 범위의 정수를 담으면 안된다는 걸 인지할 것.
double은 유효숫자가 15자리인데 long 은 최대 19자리니까 10^18+1과 10^18을 구분할 수가 없고 그냥 같은 값이 저장됨!

단! int는 최대 21억이기 때문에 double에 담아도 오차가 생기지 않음

**실수를 비교할 때는 등호를 사용 금지!
첫번째 이야기와 같은 이야기!

두 실수가 같은지 알고 싶을 때에는 둘의 차이가 아주 작은 값, 대략 10-12 이하면 동일하다고 처리를 하는게 안전**
