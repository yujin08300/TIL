피보나치 재귀
=====
재귀를 활용하여 피보나치 수를 구하는 코드는 다음과 같습니다.

<pre>
  <codee>
function fibbo(x)
    if x <= 1
        return 1
    else
        return fibbo(x - 2) + fibbo(x - 1)
 
  </codee>
</pre>

여러분들은 회사에 개발자로 채용되어 프로그램 실행 과정에 대해 연구하고 있습니다.   

이번에 여러분들의 목표는 위에서 정의한 fibbo 함수를 실행했을 때, 콜 스택에 함수가 어떻게 쌓이는지 분석하는 것입니다.  

만약 여러분들이 fibbo(6)을 실행했다고 가정하면, 시스템적으로 fibbo(1)이 처음   

호출되는 순간 콜 스택에는 fibbo(1)을 포함하여 총 몇 개의 함수가 들어있을지 생각해봅시다.   

단, fibbo(x - 2)와 fibbo(x - 1) 함수 중 fibbo(x - 2) 함수가 먼저 호출된다고 가정해도 좋습니다.  

답
---
4개

콜 스택 추적 (fibbo(6))
---

호출 fib(6) → [6]  

호출 fib(4) → [6, 4]  

호출 fib(2) → [6, 4, 2]  

호출 fib(0) → [6, 4, 2, 0] ⇒ 리턴 → [6, 4, 2]  

호출 fib(1) → [6, 4, 2, 1] ⇒ 리턴 → [6, 4, 2] ⇒ fib(2) 리턴 → [6, 4]  

호출 fib(3) → [6, 4, 3]  

호출 fib(1) → [6, 4, 3, 1] ⇒ 리턴 → [6, 4, 3]  

호출 fib(2) → [6, 4, 3, 2]  

호출 fib(0) → [6, 4, 3, 2, 0] ⇒ 리턴 → [6, 4, 3, 2]  

호출 fib(1) → [6, 4, 3, 2, 1] ⇒ 리턴 → [6, 4, 3, 2] ⇒ fib(2) 리턴 → [6, 4, 3] ⇒ fib(3) 리턴 → [6, 4] ⇒ fib(4) 리턴 → [6]  

— 이제 fib(6)의 두 번째 가지로 —  

호출 fib(5) → [6, 5]  

호출 fib(3) → [6, 5, 3]  

호출 fib(1) → [6, 5, 3, 1] ⇒ 리턴 → [6, 5, 3]  

호출 fib(2) → [6, 5, 3, 2]  

호출 fib(0) → [6, 5, 3, 2, 0] ⇒ 리턴 → [6, 5, 3, 2]  

호출 fib(1) → [6, 5, 3, 2, 1] ⇒ 리턴 → [6, 5, 3, 2] ⇒ fib(2) 리턴 → [6, 5, 3] ⇒ fib(3) 리턴 → [6, 5]  

호출 fib(4) → [6, 5, 4]  

호출 fib(2) → [6, 5, 4, 2]  

호출 fib(0) → [6, 5, 4, 2, 0] ⇒ 리턴 → [6, 5, 4, 2]  

호출 fib(1) → [6, 5, 4, 2, 1] ⇒ 리턴 → [6, 5, 4, 2] ⇒ fib(2) 리턴 → [6, 5, 4]  

호출 fib(3) → [6, 5, 4, 3]  

호출 fib(1) → [6, 5, 4, 3, 1] ⇒ 리턴 → [6, 5, 4, 3]  

호출 fib(2) → [6, 5, 4, 3, 2]  

호출 fib(0) → [6, 5, 4, 3, 2, 0] ⇒ 리턴 → [6, 5, 4, 3, 2]  

호출 fib(1) → [6, 5, 4, 3, 2, 1] ⇒ 리턴 → [6, 5, 4, 3, 2]  
⇒ fib(2) 리턴 → [6, 5, 4, 3]  
⇒ fib(3) 리턴 → [6, 5, 4]  
⇒ fib(4) 리턴 → [6, 5]  
⇒ fib(5) 리턴 → [6]  
⇒ fib(6) 리턴 → [] (완료)  
