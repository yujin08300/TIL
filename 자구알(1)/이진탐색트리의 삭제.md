이진탐색트리의 삭제
=
삭제 과정은 조금 복잡합니다. 먼저 값 x를 찾습니다. 이후 과정은 다음 3개 중 하나 입니다.  

Case 1. 값을 찾았을 때 해당 노드(node)의 왼쪽 노드가 비어있다면, node의 오른쪽 노드를 위로 올려주면 됩니다.  

Case 2. 값을 찾았을 때 해당 노드(node)의 오른쪽 노드가 비어있다면, node의 왼쪽 노드를 위로 올려주면 됩니다.  

Case 3. 값을 찾았을 때 해당 노드(node)의 왼쪽 오른쪽 노드가 전부 채워져 있다면, successor를 찾아야 합니다.  
successor란 현재 노드를 기준으로 더 크면서 가장 작은 값을 갖는 노드를 뜻합니다. 예를 들어 다음 그림에서 노드 2의 successor는 노드 3 입니다.  

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/789e5d52-d7be-437b-af68-63083076cdb6" />


successor는 현재 node의 오른쪽 자식인 node.right를 시작으로 계속 내려갈 수 있는 만큼 왼쪽으로 내려가는 방식으로 비교적 간단하게 구할 수 있습니다.  


successor를 구하고 나면, successor에 있는 값을 node에 옮겨준 뒤 successor의 오른쪽 자식을 위로 올려주면 됩니다.  


단, 다음과 같이 successor가 node의 오른쪽 자식인 경우라면 1번째 case때 처럼 단순히 node의 오른쪽 노드를 위로 올려주면 됩니다.  


코드는 다음과 같습니다. 특정 노드의 값은 value에 들어있다고 가정하며, 값 x를 찾아 삭제하는 함수입니다.  

<pre>
  <code>
function bst.search(x)
    set node = bst.root                     
    while node != null and node.value != x 
        if node.value > x                
            node = node.left           
        else                               
            node = node.right           
    
    return node            

function bst.minimum(node)                  // node 하위 트리에서 최솟값을 구합니다.
    while node.left != null                 // node의 left가 null이 아니면 계속 내려갑니다.
        node = node.left
    return node                             // 최종 node의 위치를 반환합니다.

function bst.delete(x)                      // x를 찾아 삭제하는 함수입니다.
    set node = bst.search(x)                // x 값을 찾습니다.
    
    if node.left == null                    // Case 1. node의 왼쪽 자식이 비어있다면
        move(node.right, node)              // 오른쪽 자식을 위로 올려줍니다.
    else if node.right == null              // Case 2. node의 오른쪽 자식이 비어있다면
        move(node.left, node)               // 왼쪽 자식을 위로 올려줍니다.
    else                                    // Case 3. 왼쪽 오른쪽 자식이 모두 채워져있다면
        set succ = bst.minimum(node.right)  // 해당 노드의 successor를 구합니다.
                                            // 이는 현재 노드의 오른쪽 자식에서 시작하여 계속 왼쪽으로 내려가는 것을
                                            // 반복하면 가능합니다.
        if succ == node.right               // 만약 successor가 현재 노드의 오른쪽 자식이라면 
            move(node.right, node)          // 오른쪽 자식을 위로 올려줍니다.
        else                                // 그렇지 않은 일반적인 경우라면
            node.value = succ.value         // node의 값을 successor의 값으로 대체시켜준 뒤,
            move(succ.right, succ)          // successor의 오른쪽 자식을 위로 끌어올려줍니다.

  </code>
</pre>
