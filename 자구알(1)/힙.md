힙
=

힙도 **완전 이진 트리** 형태를 가진다. (완전: 마지막 레벨만 덜 차 있을 수 있고, 왼쪽부터 채워져야 함)  

하지만 추가적인 조건이 있음:  

Max-Heap: 부모 ≥ 자식  

Min-Heap: 부모 ≤ 자식  

즉, 값의 크기까지 신경 씀.  

그래서 루트에는 항상 최댓값(또는 최솟값)이 위치한다.  

*****
**1. 힙이 뭔가?**


힙은 그냥 특별한 이진 트리다.

모양은 **완전 이진 트리** (왼쪽부터 차례대로 빈칸 없이 꽉 채운 형태).

규칙은 부모 ≥ 자식 (Max-Heap) 혹은 부모 ≤ 자식 (Min-Heap).

👉 그래서 Max-Heap의 루트에는 언제나 전체 원소 중 최댓값이 있다.  

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/f66cccfb-a8df-4247-b6f5-b6cd23af6da4" />


**2. 왜 좋은가?**

최댓값(또는 최솟값)을 찾는 시간 = O(1) (루트만 보면 되니까)

삽입, 삭제 시간 = O(log n) (트리 높이만큼만 정리하면 되니까)  

힙을 만드는 시간 = O(n)

**3. 근데 힙으로 뭐는 못하나?**

k번째 큰 값? 못 구한다.

힙은 “제일 큰 값 하나”만 빠르게 줄 수 있는 자료구조다.

👉 그래서 힙은 우선순위 큐(priority queue) 구현에 딱 맞다.
(“가장 급한 일 먼저!” → 루트에서 뽑으면 됨)

**4. 왜 힙을 만드는 건 O(n)인가?**

배열에 원소들을 쭉 넣고, 아래에서 위로 heapify 해서 힙 조건을 맞춘다.

모든 원소를 한 번씩 확인해야 하니까 기본적으로 n번은 만진다.

수학적으로 따져보면 전체 비용은 n에 비례한다.

**5. 그럼 언제 힙을 쓰는가?**

최댓값(또는 최솟값) 을 반복해서 뽑고, 중간중간 원소를 더 넣어야 할 때.

예:

운영체제에서 “우선순위 높은 작업부터 실행”

다익스트라 알고리즘에서 최단거리 노드 선택

이벤트 시뮬레이션에서 “가장 빨리 일어날 이벤트” 뽑기

*****

이진트리 (가장 큰 개념)  
├── 완전이진트리 (형태에 규칙이 있는 이진트리)  
└── 이진탐색트리 (값의 순서에 규칙이 있는 이진트리)  


*****
이번에는 힙이라 불리는 특별한 이진 트리에 대해서 알아보겠습니다. 힙 종류에는 max-heap, min-heap이 있으며,   
이 자료구조를 이용하면 특정 수가 추가되고 삭제되었을 때 원하는 heap 구조를 유지하는 데 O(logn) 만큼이 소요되며,    
이는 주어진 수들 중 최대 최소값을 O(1)에 구할 수 있도록 만들어줍니다.  

이를 이해하기 위해서는 우선 완전 이진트리라는 용어를 알아야 하는데, 이것은 트리의 모든 값이 왼쪽에서 순서대로   
차 있는 것을 의미합니다. 완전 이진 트리를 배열에 채우게 되면, 중간에 비는 값 없이 일자로 채워지는 것을 볼 수 있습니다.   

우리는 이진트리가 다음과 같이 배열을 이용하여 쉽게 표현이 가능하다고 했었습니다.  



그 중에서도 완전 이진트리를 띄는 구조 안에서, 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다   
같거나 큰 경우를 만족한다면 이를 max-heap 이라 합니다. Max Heap의 가장 중요한 특징 중 하나는,   
루트 노드에는 전체 숫자 중 최댓값이 항상 들어 있다는 것입니다.  



이렇게 max-heap을 만드는 데는 시간이 O(n) 만큼 소요되지만, 그 이후 특정 원소 하나를 삭제, 삽입했을 때에는   
완전 이진 트리에서의 삽입 삭제이므로 O(logn) 시간만 소요가 됩니다. 최댓값은 루트 노드이므로 max-heap이 만들어져 있는   
상황이라면 O(1)에 계산이 가능합니다. (max-heap 안만들어진 상태에서는 O(n). 아마도..) min-heap 역시도 max-heap 구조와 정확히 동일합니다.  

다만, max-heap에서의 삭제는 루트 노드에서만 가능합니다.  
max-heap을 이용하면 삽입, 삭제에 O(logn)만큼의 시간만 소요하여 그 다음 최댓값을 루트로 올려줄 수 있지만   
삭제는 항상 루트 노드만 가능함에 꼭 유의합니다. 또한 **max-heap에서는 k 번째 최댓값을 구할 수 없습니다.**  
항상 **가장 큰 값이 무엇인지만** 알 수 있는 자료구조입니다. 따라서 루트 노드를 제외하고는 다른 원소들이   
어느 위치에 있을지 아무도 알 수 없습니다. 끝으로 n개의 숫자들 중 최댓값을 단 한 번만 찾아야 하는 경우라면   
max-heap을 만든 뒤 루트 노드를 봐야하므로 시간이 O(n)만큼 소요되기 때문에, 이 경우에는 간단히 순차탐색을 통해   
O(n)에 최댓값을 찾는 것이 더 편리합니다. 이처럼 **원소의 추가, 그리고 최댓값의 삭제가 빈번하게 일어나는 상황에서**   
**현재 남아있는 원소들 중 최댓값을 빠르게 계속 얻고 싶은 경우**에만 heap 자료구조가 유용하다는 사실을 꼭 이해하고 넘어가야 합니다.  


