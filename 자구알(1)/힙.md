힙
=

힙도 완전 이진 트리 형태를 가진다. (완전: 마지막 레벨만 덜 차 있을 수 있고, 왼쪽부터 채워져야 함)  

하지만 추가적인 조건이 있음:  

Max-Heap: 부모 ≥ 자식  

Min-Heap: 부모 ≤ 자식  

즉, 값의 크기까지 신경 씀.  

그래서 루트에는 항상 최댓값(또는 최솟값)이 위치한다.  


이번에는 힙이라 불리는 특별한 이진 트리에 대해서 알아보겠습니다. 힙 종류에는 max-heap, min-heap이 있으며,   
이 자료구조를 이용하면 특정 수가 추가되고 삭제되었을 때 원하는 heap 구조를 유지하는 데 O(logn) 만큼이 소요되며,    
이는 주어진 수들 중 최대 최소값을 O(1)에 구할 수 있도록 만들어줍니다.  

이를 이해하기 위해서는 우선 완전 이진트리라는 용어를 알아야 하는데, 이것은 트리의 모든 값이 왼쪽에서 순서대로   
차 있는 것을 의미합니다. 완전 이진 트리를 배열에 채우게 되면, 중간에 비는 값 없이 일자로 채워지는 것을 볼 수 있습니다.   

우리는 이진트리가 다음과 같이 배열을 이용하여 쉽게 표현이 가능하다고 했었습니다.  



그 중에서도 완전 이진트리를 띄는 구조 안에서, 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다   
같거나 큰 경우를 만족한다면 이를 max-heap 이라 합니다. Max Heap의 가장 중요한 특징 중 하나는,   
루트 노드에는 전체 숫자 중 최댓값이 항상 들어 있다는 것입니다.  



이렇게 max-heap을 만드는 데는 시간이 O(n) 만큼 소요되지만, 그 이후 특정 원소 하나를 삭제, 삽입했을 때에는   
완전 이진 트리에서의 삽입 삭제이므로 O(logn) 시간만 소요가 됩니다. 최댓값은 루트 노드이므로 max-heap이 만들어져 있는   
상황이라면 O(1)에 계산이 가능합니다. (max-heap 안만들어진 상태에서는 O(n). 아마도..) min-heap 역시도 max-heap 구조와 정확히 동일합니다.  

다만, max-heap에서의 삭제는 루트 노드에서만 가능합니다.  
max-heap을 이용하면 삽입, 삭제에 O(logn)만큼의 시간만 소요하여 그 다음 최댓값을 루트로 올려줄 수 있지만   
삭제는 항상 루트 노드만 가능함에 꼭 유의합니다. 또한 **max-heap에서는 k 번째 최댓값을 구할 수 없습니다.**  
항상 **가장 큰 값이 무엇인지만** 알 수 있는 자료구조입니다. 따라서 루트 노드를 제외하고는 다른 원소들이   
어느 위치에 있을지 아무도 알 수 없습니다. 끝으로 n개의 숫자들 중 최댓값을 단 한 번만 찾아야 하는 경우라면   
max-heap을 만든 뒤 루트 노드를 봐야하므로 시간이 O(n)만큼 소요되기 때문에, 이 경우에는 간단히 순차탐색을 통해   
O(n)에 최댓값을 찾는 것이 더 편리합니다. 이처럼 **원소의 추가, 그리고 최댓값의 삭제가 빈번하게 일어나는 상황에서**   
**현재 남아있는 원소들 중 최댓값을 빠르게 계속 얻고 싶은 경우**에만 heap 자료구조가 유용하다는 사실을 꼭 이해하고 넘어가야 합니다.  
